package org.tulg.roundback.core;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.ByteBuffer;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Base64;

/**
 * @author Jason Williams <jasonw@tulg.org>
 *
 * class Encrypter - Handles encryption and decrytion of strings and byte arrays.
 */
public class Encrypter {

    /**
     * Returns a String of BASE64 encoded characters that represents the encrypted data.
     * <p>
     * Useful for network communications, and small encryption that is terminated by newlines.
     *
     * @param  key          a key that can be passed to the Cipher.
     * @param  initVector   an initVector generated by getIVBytes()
     * @param  value        the string to encrypt.
     * @return              the BASE64 encoded string of the encrypted data.
     */
    public static String encrypt(String key, byte [] initVector, String value) {
        try {
            // Set up the Cipher
            IvParameterSpec iv = new IvParameterSpec(initVector);
            SecretKeySpec pbeKey = new SecretKeySpec(hashString(key), "AES");
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
            cipher.init(Cipher.ENCRYPT_MODE, pbeKey, iv);

            // do the encryption
            byte[] encrypted = cipher.doFinal(value.getBytes());



            // add the IV to the beginning of the encrypted string.
            byte [] encryptedWithIV = new byte[initVector.length + encrypted.length];
            System.arraycopy(initVector, 0, encryptedWithIV, 0, initVector.length);
            System.arraycopy(encrypted, 0, encryptedWithIV, initVector.length, encrypted.length);

            // return the string with the IV attached.
            return Base64.getEncoder().encodeToString(encryptedWithIV);
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return null;
    }

    /**
     * Returns a byte []  that represents the encrypted data.
     * <p>
     * Useful for encrypting files and streams.
     *
     * @param  key          a key that can be passed to the Cipher.
     * @param  initVector   an initVector generated by getIVBytes()
     * @param  value        the byte string to encrypt.
     * @return             byte array of the encrypted data.
     */
    public static byte [] encrypt(String key, byte [] initVector, byte [] value) {
        try {

            // init the cipher.
            IvParameterSpec iv = new IvParameterSpec(initVector);
            SecretKeySpec pbeKey = new SecretKeySpec(hashString(key), "AES");

            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
            cipher.init(Cipher.ENCRYPT_MODE, pbeKey, iv);

            // do the encryption
            byte[] encrypted = cipher.doFinal(value);

            // get the length of the ecrypted data.
            int dataLen = encrypted.length;

            // and convert it to a byte array.
            ByteBuffer byteBuffer = ByteBuffer.allocate(4);
            byteBuffer.putInt(dataLen+initVector.length);
            byte [] dataLenBytes = byteBuffer.array();

            // allocate a buffer for the encrypted string with the IV
            byte [] encryptedWithIV = new byte[initVector.length + encrypted.length + 4];

            // assemble the byte array to be stored/sent.
            // encrypted data length comes first.
            System.arraycopy(dataLenBytes, 0, encryptedWithIV, 0, 4);
            // add the IV to the encrypted string.
            System.arraycopy(initVector, 0, encryptedWithIV, 4, initVector.length);
            System.arraycopy(encrypted, 0, encryptedWithIV, initVector.length+4, encrypted.length);

            return encryptedWithIV;
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return null;
    }

    /**
     * returns the integer value of the bytes stored in a 4 byte array.
     *
     * @param  by           the byte array to covert.
     * @return              an integer representing the value of the bytes.
     */

    public static int byteToInt(byte [] by) {
        int value = 0;
        for (int i = 0; i < 4; i++)
        {
            value = (value << 8) + (by[i] & 0xff);
        }
        return value;
    }


    /**
     * Decrypts a byte array previously encrypted with Encrypter.encrypt()
     *
     * @param  key          a key that can be passed to the Cipher.
     * @param  encrypted    the byte string to decrypt.
     * @return              byte array of the decrypted data.
     */
    public static byte [] decrypt(String key, byte [] encrypted) {
        try {
            // first 16 bytes are the IV.
            //byte []tmpEncWithIV = encrypted;
            byte []tmpIV = new byte[16];
            byte []tmpEnc = new byte[encrypted.length-16];
            System.arraycopy(encrypted, 0, tmpIV, 0, 16);
            System.arraycopy(encrypted, 16, tmpEnc, 0, encrypted.length-16);

            IvParameterSpec iv = new IvParameterSpec(tmpIV);
            SecretKeySpec pbeKey = new SecretKeySpec(hashString(key), "AES");

            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
            cipher.init(Cipher.DECRYPT_MODE, pbeKey, iv);

            return cipher.doFinal(tmpEnc);
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return null;
    }


    /**
     * Decrypts a BASE64 encoded string previously encrypted with Encrypter.encrypt()
     *
     * @param  key          a key that can be passed to the Cipher.
     * @param  encrypted    the string to decrypt.
     * @return              String of the decrypted data.
     */
    public static String decrypt(String key, String encrypted) {
        try {
            // first 16 bytes are the IV.
            byte []tmpEncWithIV = Base64.getDecoder().decode(encrypted.getBytes());
            byte []tmpIV = new byte[16];
            byte []tmpEnc = new byte[tmpEncWithIV.length-16];
            System.arraycopy(tmpEncWithIV, 0, tmpIV, 0, 16);
            System.arraycopy(tmpEncWithIV, 16, tmpEnc, 0, tmpEncWithIV.length-16);

            IvParameterSpec iv = new IvParameterSpec(tmpIV);
            SecretKeySpec pbeKey = new SecretKeySpec(hashString(key), "AES");

            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
            cipher.init(Cipher.DECRYPT_MODE, pbeKey, iv);

            /*
            byte[] original = cipher.doFinal(tmpEnc);
            String returnString = new String(original);
            */
            return new String(cipher.doFinal(tmpEnc));
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return null;
    }

    /**
     * Get an IV (Initial Vector) For use in the encryption.
     *
     * @return              Bytes used as an IV for the encrytion generated from a random number
     */
    public static byte [] getIVBytes(){
        SecureRandom secureRandom = new SecureRandom();
        byte []tmpIV;
        tmpIV = secureRandom.generateSeed(16);
        return tmpIV;
    }

    private static byte[] hashString(String stringToHash){
        MessageDigest m = null;
        try {
            m = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        if(m != null) {
            m.update(stringToHash.getBytes(), 0, stringToHash.getBytes().length);
            return m.digest();
        }
        return null;
    }

}
