package org.tulg.roundback.core;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.HashMap;

//import org.tulg.roundback.core.RoundBack;
import org.tulg.roundback.master.MasterDB;
/**
 * Base class for all RoundBack Data Objects. Contains
 * code for db storage and code for querying the 
 * master server for objects.
 * 
 */
public class RoundBackObject {
    protected MasterDB db; 
    protected String table = "";

    /**
     * Initialize the table for a given object type.  Should be
     * called from a properly setup object type that extends this
     * base class.
     *
     * @param  key          a key that can be passed to the Cipher.
     * @param  initVector   an initVector generated by getIVBytes()
     * @param  value        the string to encrypt.
     * @return              the BASE64 encoded string of the encrypted data.
     */
    public boolean initializeDB(){
        if(RoundBack.getInstanceType() != RoundBack.MASTER){
            Logger.log(Logger.LOG_LEVEL_CRITICAL, "Invalid invocation of initializeDB(), should only be called from a master instance.");
            return false;
        }

        if(this.table == "") {
            Logger.log(Logger.LOG_LEVEL_CRITICAL, "Invalid invocation of initializeDB(), table must be set by child class: " + this.getClass().getSimpleName());
            return false;
        }

        if(this.getClass().getSimpleName().equals("RoundBackObject")){
            Logger.log(Logger.LOG_LEVEL_CRITICAL, "Invalid invocation of initializeDB(), must not be called on base class");
            return false;
        }

        

        HashMap<String, String>fields = this.getFieldsFiltered();
        
        /*new HashMap<String, String>();
        for( Field f : this.getClass().getDeclaredFields()){
            
            // filter out types.
            String fieldType = f.getType().toString();
            if(fieldType.equals("class java.lang.String")){
                fieldType = "TEXT";
            } else if (fieldType.equals("int")){
                fieldType = "INT";
            } else {
                continue;
            }

            // filter out names
            if(f.getName() == "db" || f.getName() == "table"){
                continue;
            }

            // filter out locals
            if(f.getName().startsWith("l_")){
                continue;
            }

            // filter out statics and finals
            if(Modifier.isStatic(f.getModifiers()) || Modifier.isFinal(f.getModifiers())){
                continue;
            }

            // filter out fields with unsupported types.
            if(fieldType == "" )
                continue;

            fields.put(f.getName(), fieldType);
        }*/
        if(fields.size() >0){
            if(db.open()){
                // we successfully opened the db.
                // check if the table exists
                if(db.tableExists(table)){
                    Logger.log(Logger.LOG_LEVEL_DEBUG, this.getClass().getSimpleName() +  ": Table " + table + " already exists, skipping.");
                    db.close();
                    return true;
                }
                db.createTable(fields);
            }
        } else {
            Logger.log(Logger.LOG_LEVEL_DEBUG, "Create Table skipped for " + this.getClass().getSimpleName() + ": No Fields");
        }
        db.close();
        

        return true;
    }

    public HashMap<String, String> getFieldsFiltered(){
        
        HashMap<String, String>fields = new HashMap<String, String>();
        for( Field f : this.getClass().getDeclaredFields()){
            // only include 'rbdbf_' fields
            if(!f.getName().startsWith("rbdbf_")){
                continue;
            }

            // filter out types.
            String fieldType = f.getType().toString();
            if(fieldType.equals("class java.lang.String")){
                fieldType = "TEXT";
            } else if (fieldType.equals("int")){
                fieldType = "INT";
            } else {
                continue;
            }

            // filter out statics and finals
            if(Modifier.isStatic(f.getModifiers()) || Modifier.isFinal(f.getModifiers())){
                continue;
            }

            // filter out fields with unsupported types.
            if(fieldType == "" )
                continue;

            fields.put(f.getName(), fieldType);
        }
        return fields;
    }
}